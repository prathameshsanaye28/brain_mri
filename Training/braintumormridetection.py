# -*- coding: utf-8 -*-
"""BrainTumorMRIDetection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hi0NSF40mjqc---nYwQ4-J-oAr7ApLKx

# Brain Tumor MRI Detection
"""

import tensorflow as tf

# TensorFlow automatically detects and uses the Metal GPU
print(f"GPU available: {tf.config.list_physical_devices('GPU')}")

pip install tensorflow

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
import os
import numpy as np
from PIL import Image

current_dir = os.getcwd()
print ("Current Directory: " + current_dir)

train_dir = os.path.join(current_dir, 'Testing')
val_dir = os.path.join(current_dir, 'Training')

# Define the target size and batch size
target_size = (1250, 1250)
batch_size = 32

# Define the training and validation data generators
train_datagen = ImageDataGenerator(rescale=1./255)
train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=target_size,
    batch_size=batch_size,
    class_mode='categorical')

val_datagen = ImageDataGenerator(rescale=1./255)
val_generator = val_datagen.flow_from_directory(
    val_dir,
    target_size=target_size,
    batch_size=batch_size,
    class_mode='categorical')

# Define the model
model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu',
                           input_shape=(target_size[0], target_size[1], 3)),
    tf.keras.layers.MaxPooling2D((2, 2)),
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D((2, 2)),
    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D((2, 2)),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(train_generator.num_classes, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# Train the model
history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples//batch_size,
    epochs=15,
    validation_data=val_generator,
    validation_steps=val_generator.samples//batch_size)

"""Saving The Model"""

# Save the trained model in the current directory
model.save(os.path.join(current_dir, 'model.h5'))

model = load_model('model.h5')

def prediction(predicted_no):
    if predicted_no==1:
        return 'giloma'
    elif predicted_no==2:
        return 'meningioma'
    elif predicted_no==3:
        return 'no tumor'
    elif predicted_no==4:
        return 'pitutary'
    else: return 'error'

# Load and preprocess your image
img_path = 'pitutuary.jpg'
img = image.load_img(img_path, target_size=(1250, 1250))  # Resize to 1250x1250
img_array = image.img_to_array(img)  # Convert to array
img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
img_array = img_array / 255.0  # Normalize to [0, 1]

# Make a prediction
predictions = model.predict(img_array)
predicted_class = np.argmax(predictions, axis=1)

print(predicted_class)

